from re import sub

from alive_progress import alive_bar
from forge.entities.base import Base
from forge.entities.contentview import ContentViews
from forge.entities.product import Products
from forge.entities.repository_set import RepositorySets
from forge.entities.subscription import Subscriptions
from logzero import logger as log


class ActivationKeys(Base):
  """Forged ActivationKeys object.
  Matches nailgun.entity.ActivationKey

  :param Base: forge.entities.Base
  :type Base: BaseClass
  :return: List of ActivationKey entities
  :rtype: list
  """
  def __init__(self, cfg, org):
    """Class initialization

    :param cfg: Configuration object
    :type cfg: forge.config
    :param org: forged Org object
    :type org: forge.entities.Org
    """
    self.entity = "ActivationKey"
    super().__init__(cfg, org=org)

  def get_by_cv(self, cv):
    return self.search(None, **{"content_view_id": cv.id})

  def create_all(self, releases):
    """Loops through the configured releases and generates the ActivationKeys

    :param releases: List of releases generated by make/base:read_releases
    :type releases: list
    """
    # If a release has an ak_sub configured, we need to try to add a  matching
    # product to the AK. For this, we need to pull the subs, products and reposets
    releases_sub = list(filter(lambda x: "ak_sub" in releases[x], releases))
    if len(releases_sub):
      log.info("Some AKs must be attached to subs.")
      self.load_sub_metadata()
    for release in releases:
      r = releases[release]
      self.release_subs = []
      label_list = r["labels"].split(",")
      reposets = self.reposet.get_by_labels(label_list)
      sub_match = r["ak_sub"] if "ak_sub" in r else None
      self.get_subs(reposets, sub_match)
      if len(self.release_subs):
        log.info(f"Will attach to {[s.name for s in self.release_subs]}")
      cvs = ContentViews(self._cfg, self.org).get_by_releases(release)
      if r["container"]:
        cvs = list(filter(lambda x: x.composite, cvs))
      total_ak = sum([len(cv.environment) for cv in cvs])
      with alive_bar(total_ak * 3, title="Creating AK") as bar:
        for cv in cvs:
          for env in cv.environment:
            self.create_for_cv(cv, env, r["releasever"], bar, label_list)

  def add_sub(self, sub):
    """ Adding a subscription to the subscription list if it's not there

    :param sub: Subscription to append
    :type sub: nailgun.entity.Subscription
    """
    if sub not in self.release_subs:
      self.release_subs.append(sub)

  def get_subs(self, reposets, sub_match=None):
    """Get the best matching sub for a list of reposets

    :param reposets: List of RepositorySet entities
    :type reposets: list, nailgun.entity.RepositorySet
    :param sub_match: Subscription name to look for, defaults to None
    :type sub_match: str, optional
    """
    for repo in reposets:
      # for each repo, we get the product id
      product = self.products.find(repo.product.id, "id")
      # And this is giving us all the subs available for that product
      product_subs = self.subs.get_subs_for_product(product)
      matching_subs = []
      if sub_match:
        matching_subs = list(filter(lambda x: sub_match in x.name,
          product_subs))
      if len(matching_subs):
        log.info(
          f"[{repo.name}] Found {len(matching_subs)} matching sub(s), "
          f"using the first one: {matching_subs[0].name}")
        self.add_sub(matching_subs[0])
      else:
        psub = sorted(product_subs, key=lambda x: x.quantity, reverse=True)[0]
        log.warning(
          f"[{repo.name}] Found no matching sub, using first "
          f"product subs {psub.name}")
        self.add_sub(psub)

  def load_sub_metadata(self):
    """Loads the Subscriptions, Products and RepositorySets metadata
    """
    with alive_bar(3, title="Loading data") as bar:
      self.log_bar("Loading subs", bar)
      self.subs = Subscriptions(self._cfg)
      self.subs.get_all_subs()
      self.log_bar("Loading products", bar)
      self.products = Products(self._cfg, self.org)
      self.products.get_all()
      self.log_bar("Loading repos", bar)
      self.reposet = RepositorySets(self._cfg, self.org)

  def create_for_cv(self, cv, env, releasever, bar, labels=[]):
    """ Creates an ActivationKey for a ContentView's environment

    :param cv: ContentView entity
    :type cv: nailgun.entity.ContentView
    :param env: LifecycleEnvironment entity
    :type env: nailgun.entity.LifecycleEnvironment
    :param releasever: Release Version (ex: 7Server, 8.2, etc)
    :type releasever: str
    :param bar: Alive progress bar context
    :type bar: context
    :param labels: List of labels to enable in content_override,
                   defaults to []
    :type labels: list, optional
    """
    item = self.new_item()
    env = env.read()
    item.name = sub(r"^[C]{1,2}V_", f"AK_{env.label.capitalize()}_", cv.label)
    self.log_bar(f"Creating {item.name}", bar)
    item.content_view = cv
    item.environment = env
    item.release_version = releasever
    item.unlimited_hosts = True
    item.auto_attach = True
    self.create(item)
    self.log_bar(f"Adding subs to {item.name}", bar)
    if len(self.release_subs):
      active_subs = self.item.subscriptions()["results"]
      for subc in self.release_subs:
        added = list(filter(lambda x: x["subscription_id"] == subc.subscription.id,
                            active_subs))
        if not len(added):
          self.item.add_subscriptions(data={
            'subscription_id': subc.id
          })
        else:
          log.debug(f"Subscription {subc.name} already added to AK")

    self.log_bar(f"Setting content override for {item.name}", bar)
    if len(labels):
      overrides = []
      for label in labels:
        overrides.append({
            'content_label': label,
            'name': 'enabled',
            'value': '1'
            })
      self.item.content_override(data={'content_overrides': overrides})
