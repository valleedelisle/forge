import sys
from re import match, sub
from time import sleep

from alive_progress import alive_bar
from forge.entities.base import Base
from forge.entities.contentviewfilterrule import ContentViewFilterRules
from forge.entities.dockercontentviewfilter import \
    DockerContentViewFilters  # noqa: F401,E501
from forge.entities.erratumcontentviewfilter import \
    ErratumContentViewFilters  # noqa: F401,E501
from forge.entities.lifecycle_environment import LifecycleEnvironments
from forge.entities.modulestreamcontentviewfilter import \
    ModuleStreamContentViewFilters  # noqa: F401,E501
from forge.entities.organization import Org
from forge.entities.repository import Repositories
from forge.entities.repository_set import RepositorySets
from forge.entities.rpmcontentviewfilter import \
    RPMContentViewFilters as RpmContentViewFilters  # noqa: F401,E501
from logzero import logger as log


class ContentViews(Base):
  """Forged ContentViews object.
  Matches nailgun.entity.ContentView

  :param Base: forge.entities.Base
  :type Base: BaseClass
  :return: List of ContentView entities
  :rtype: list
  """
  def __init__(self, cfg, org):
    """Class initialization

    :param cfg: Configuration object
    :type cfg: forge.config
    :param org: forged Org object
    :type org: forge.entities.Org
    """
    self.entity = "ContentView"
    super().__init__(cfg, org)

  def create_all(self, releases, promote_only, composite_only, force=False):
    """Loops through the configured releases and generates the ContenViews

    :param releases: List of releases generated by make/base:read_releases
    :type releases: list
    :param promote_only: Run promotes only
    :type promote_only: bool
    :param composite_only: Run on composite content views only
    :type composite_only: bool
    :param force: Runs operation even if tasks are still running. Defaults to False
    :type force: bool, optional
    """
    self.created_cvs = []
    for release in releases:
      r = releases[release]
      if not force:
        self.block_by_running_tasks()
      if not composite_only:
        if not promote_only:
          self.create_rhel_cvs(r, release)
          if r["container"]:
            self.create_container_cvs(r, release)
        self.promote_all(releases, force=force)
      if composite_only or (not promote_only and r["container"]):
        self.create_composite_cvs(r, release)
        self.promote_all(releases, composites=True, force=force)

  def create_rhel_cvs(self, r, release):
    """Function to create the RHEL CVs with erratum date filter
    and RPMs without Errata, based on the cvs and zdates sections
    of the configuration

    :param r: Sub dictionnary from the releases dict
    :type r: dict
    :param release: Release name (OSP10, OSP13, OSP16.1, etc)
    :type release: str
    """
    repos = RepositorySets(self._cfg, self.org).get_by_labels(r["labels"]
                                               .split(","))
    with alive_bar(len(r["zdates"].items()) * 4, title="RHEL CVS") as bar:
      for zrelease, date in r["zdates"].items():
        if zrelease == "latest":
          continue
        # For some reason, configparser lowers everything like this
        zrelease = "GA" if zrelease == "ga" else zrelease
        self.log_bar(f"Generating RHEL CV {release}-{zrelease}", bar)
        self.generate_cv("RHEL", r, release, zrelease, repos=repos)
        self.log_bar(f"Deleting existing filters {release}-{zrelease}", bar)
        # self.delete_filters(self.item, "erratum")
        # self.delete_filters(self.item, "rpm")
        self.log_bar(f"Adding filters {release}-{zrelease}", bar)
        if date != "latest":
          self.generate_filter("erratum", self.item, repos, date=date)
          self.generate_filter("rpm", self.item, repos)
          self.generate_filter("module_stream", self.item, repos)
        self.log_bar(f"Publishing {release}-{zrelease}", bar)
        self.item.publish(
          synchronous=self._cfg.satellite.getboolean("async_publish"),
          timeout=3600)
        self.created_cvs.append(self.item)

  def create_container_cvs(self, r, release):
    """Function to create the Container CVs based on the cvs, and containertags
    sections of the configuration

    :param r: Sub dictionnary from the releases dict
    :type r: dict
    :param release: Release name (OSP10, OSP13, OSP16.1, etc)
    :type release: str
    """
    repos = Repositories(self._cfg, self.org).get_containers(release)
    with alive_bar(len(r["zstream"]) * 4, title="Container CVS") as bar:
      for zrelease in r["zstream"]:
        self.log_bar(f"Generating Container CV {release}-{zrelease}", bar)
        self.generate_cv("Container", r, release, zrelease, repos=repos)
        self.log_bar(f"Deleting existing filters {release}-{zrelease}", bar)
        # self.delete_filters(self.item, "docker")
        self.log_bar(f"Adding filters {release}-{zrelease}", bar)
        for repo in repos:
          openstack_repo_name = f"openstack-{repo.name}"
          try:
            tag = r["zstream"][zrelease][f"openstack-{repo.name}"]
          except KeyError:
            try:
              tag = r["zstream"][zrelease][repo.name]
            except KeyError:
              log.warning(
                f"{openstack_repo_name} is not in the zstream tag list for "
                f"{release}-{zrelease}, no filter generated.")
              continue
          version = f"{release}{zrelease}".replace("z", ".").replace("OSP", "")
          self.generate_filter("docker", self.item, [repo], tag=tag,
            default_tag=version)
        self.log_bar(f"Publishing {release}-{zrelease}", bar)
        self.item.publish(
          synchronous=self._cfg.satellite.getboolean("async_publish"))
        self.created_cvs.append(self.item)

  def create_composite_cvs(self, r, release):
    """ Creates all the composite content views based
    on the information we have in r, matchin release

    :param r: Sub dictionnary from the releases dict
    :type r: dict
    :param release: Release name (OSP10, OSP13, OSP16.1, etc)
    :type release: str
    """
    self.get_all()
    with alive_bar(len(r["zstream"]) * 3, title="Composite CVS") as bar:
      for zrelease in r["zstream"]:
        cvvs = []
        for cv in self.items:
          if match(rf"CV .*{release}-{zrelease}$", cv.name):
            log.debug(f"Adding {cv.name} to CCV")
            cvvs.append(cv.version[-1])
        if len(cvvs):
          self.log_bar(f"Generating CCV {release}-{zrelease}", bar)
          self.generate_cv("CCV", r, release, zrelease, cvvs=cvvs)
          self.log_bar(f"Publishing {release}-{zrelease}", bar)
          self.item.publish(synchronous=False)
          self.created_cvs.append(self.item)
        else:
          log.warning(f"No Content views found for {release}-{zrelease}")
          bar("Skipped")
          bar("Skipped")

  def delete_filters(self, cv, filter_type):
    """ Deletes all the filters associated with a ContentView

    :param cv: ContentView entity to delete filters from
    :type cv: entity.ContentView
    :param filter_type: Either docker, rpm, erratum
    :type filter_type: str
    """
    cvf = self.get_cvf_obj(filter_type)
    filters = self._raw_req("get", f"/content_views/{cv.id}/filters",
      {"type": filter_type})
    for f in filters:
      log.info(f"Deleting filter {f['name']} from {cv.name}")
      log.debug(f)
      item = cvf.new_item()
      item.id = f["id"]
      item.delete()

  def generate_cv(self, cv_type, r, release, zrelease, repos=[], cvvs=[]):
    """This generates the CV object and pushes it on satellite

    :param cv_type: Should be either "RHEL" or "Container"
    :type cv_type: str
    :param r: Sub dictionnary from the releases dict
    :type r: dict
    :param release: Release name (OSP10, OSP13, OSP16.1, etc)
    :type release: str
    :param zrelease: Zrelease name (z1, z2, etc)
    :type zrelease: str
    :param repos: List of RepositorySet entities, used when generating RHEL
    ContentViews, defaults to []
    :type repos: list, optional
    :param cvvs: List of ContentViewVersion entitles, used when generating
    CompositeContentView, defaults to []
    :type cvvs: list, optional
    :return: generated ContentView entity
    :rtype: nailgun.entity.ContentView
    """
    item = self.new_item()
    item.organization = Org(self._cfg, name=r["org"]).item
    if cv_type == "CCV":
      item.auto_publish = r["auto_publish"]
      item.composite = True
      item.component = cvvs
    else:
      item.repository = repos
      cv_type = "CV " + cv_type
    item.name = f"{cv_type} {r['tag']} {release}-{zrelease}"
    item.label = sub(r'[\s]+|\.', '_', item.name)
    log.debug(f"Creating CV {item.name}")
    for repo in repos:
      log.debug(f"Adding repo: {repo.label}")
    item = self.create(item)
    return item

  def generate_filter(self, filter_type, cv, repos, date=None, tag=None,
    default_tag="latest"):
    """This generates the ContentViewFilter object

    :param filter_type: Can be either "docker", "rpm" or "erratum"
    :type filter_type: str
    :param cv: ContentView entity to generate filters on
    :type cv: nailgun.entity.ContentView
    :param repos: List of RepositorySet entities to filter on
    :type repos: list, optional
    :param date: Date to apply "erratum" or "rpm" filter, defaults to None
    :type date: str, YYYY-MM-DD, optional
    :param tag: Tag to filter on for "docker" filter, defaults to None
    :type tag: str, optional
    :param default_tag: Also filter on default tag, defaults to "latest"
    :type default_tag: str, optional
    :return: FilterTypeContentViewFilter entity
    :rtype: nailun.entity.FilterTypeContentViewFilter
    """
    if tag == "latest":
      return
    cvf = self.get_cvf_obj(filter_type)
    cvf.item.label = sub(r"^CV_", f"CVF_{self.camel_case(filter_type)}_", cv.label)
    if filter_type == "docker":
      cvf.item.label += f"_{repos[0].name}_{tag}"
    cvf.item.name = cvf.item.label
    cvf.item.repository = repos
    cvf.item.content_view = cv
    log.debug(f"Making CVF {cvf.item.name} {cvf.item.type} ")
    for repo in repos:
      log.debug(f"Adding repo {repo.label}")
    cvf.item = cvf.create(cvf.item)
    if date or tag:
      self.generate_filter_rules(cvf.item, cv, date, tag)
      if tag and default_tag != tag:
        self.generate_filter_rules(cvf.item, cv, date, default_tag)
    return cvf.item

  def generate_filter_rules(self, cvf, cv, date=None, tag=None):
    """This generates the ContentViewFilter object

    :param cvf: ContentViewFilter entity from which we crete the rule
    :type cvf: nailgun.entity.FilterTypeContentViewFilter
    :param cv: ContentView entity to generate filters on
    :type cv: nailgun.entity.ContentView
    :param date: Date to apply "erratum" or "rpm" filter, defaults to None
    :type date: str, YYYY-MM-DD, optional
    :param tag: Tag to filter on for "docker" filter, defaults to None
    :type tag: str, optional
    :return: ContentViewFilterRule entity
    :rtype: nailun.entity.ContentViewFilterRule
    """
    cvfr_c = {"content_view_filter": cvf}
    cvfr_name = cvf.name.replace("CVF_", "CVFR_")
    log.debug(f"Making CVFR {cvfr_name}")
    cvfr = ContentViewFilterRules(self._cfg, **cvfr_c)
    if cvf.type == "erratum":
      cvfr.item.types = ['security', 'enhancement', 'bugfix']
      cvfr.item.end_date = date
      cvfr.item.date_type = "issued"
    if cvf.type == "docker":
      cvfr.item.name = tag
    cvfr.create(cvfr.item)
    return cvfr.item

  def get_by_releases(self, releases, zreleases=[]):
    """ Returns the list of ContentView entities matching a list of releases
    and optionnaly zreleases

    :param releases: List of releases generated by make/base:read_releases
    :type releases: list or str
    :param zreleases: List of zreleases to look for (ex: ['z1', 'z2]),
                      defaults to []
    :type zreleases: list, optional
    :return: List of ContentView entities
    :rtype: list, nailgun.entity.ContentView
    """
    self.get_all()
    if type(releases) is dict:
      cv_list = self.filter_items_by_names(self.items, releases.keys())
    elif type(releases) is str:
      cv_list = list(filter(lambda x: releases in x.name.split()[-1], self.items))
    if len(zreleases):
      cv_list = self.filter_items_by_names(cv_list, zreleases)
    return cv_list

  def get_cvf_obj(self, filter_type):
    """Generates a forged FilterTypeContentViewFilters object

    :param filter_type: Can be either "docker", "rpm" or "erratum"
    :type filter_type: str
    :return: New forged FilterTypeContentViewFilters object
    :rtype: forge.entities.FilterTypeContentViewFilters
    """
    return getattr(sys.modules[__name__],
      f"{self.camel_case(filter_type)}ContentViewFilters")(self._cfg)

  def camel_case(self, value):
    """Converts a string to CamelCase name for easy import.
    Underscores are word delemiter. For example:
    `module_stream` will be converted to `ModuleStream`

    :param value: String to camel case
    :type value: str
    :return: CamelCase conversion of string
    :rtype: str
    """
    return "".join(list(map(lambda m: m.capitalize(), value.split("_"))))

  def get_created_cvs_names(self):
    return ", ".join([x.name for x in self.created_cvs])

  def filter_items_by_names(self, items, name_list):
    return list(filter(lambda x: len([x for y in name_list
                                      if y in x.name.split()[-1]]),
                                      items))

  def promote_all(self, releases, composites=False, force=False):
    """Promotes all the created ContentViews to all environments.
    If self.created_cvs list is empty, all matching ContentViews are
    promoted.

    :param releases: List of releases generated by make/base:read_releases
    :type releases: list
    :param composites: Only promote composite content-views, defaults to False
    :type composites: bool, optional
    :param force: Runs operation even if tasks are still running. Defaults to False
    :type force: bool, optional
    """
    log.info("Promoting all published content_views")
    envs = LifecycleEnvironments(self._cfg, self.org)
    envs.get_all()
    envs.items.sort(key=lambda x: x.id)
    envs.items.pop(0)
    if not hasattr(self, "created_cvs") or not self.created_cvs:
      log.warning("Didn't find the list of created ContentViews, promoting "
                  "them all")
      self.created_cvs = self.get_by_releases(releases)
    # we need to remove the default content view
    self.created_cvs = list(filter(lambda x: x.id > 1, self.created_cvs))
    # Filter wether or not we want to promote CCVs.
    self.created_cvs = list(filter(lambda x: x.composite == composites,
                                   self.created_cvs))
    if not force:
      self.block_by_running_tasks()

    log.debug(f"Promoting these CVS: {self.get_created_cvs_names()}")
    initial_length = len(self.created_cvs)
    with alive_bar(initial_length * 2, title="Promoting CVS") as bar:
      while len(self.created_cvs):
        for cv in self.created_cvs[:]:
          ccv = cv.read()
          if len(ccv.version):
            cv_version = sorted(list(map(lambda x: x.read(), ccv.version)),
                                          key = lambda x: float(x.version))[-1]
            envs_id = list(map(lambda x: x.id, envs.items))
            log.debug(
              f"Promoting {cv.name} (version_id {cv_version.id})"
              f" to {envs_id}")
            timeout = 600
            if cv.composite or "CV Container" in cv.name:
              timeout = 1800
            self.log_bar(f"Promoting {cv.name}", bar)
            self.nailrun(cv_version, "promote", timeout=timeout,
                         data={u'environment_ids': envs_id, u'force': True})
            self.log_bar(f"Promoted {cv.name}", bar)
            self.created_cvs.remove(cv)
        if len(self.created_cvs):
          log.info(f"Waiting for these CVS: {self.get_created_cvs_names()}")
          sleep(3)
    log.info("Promotion completed")
